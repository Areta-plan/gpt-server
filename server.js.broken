// server.js
require('dotenv').config();

// í™˜ê²½ë³€ìˆ˜ ìœ íš¨ì„± ê²€ì¦
if (!process.env.OPENAI_API_KEY) {
  console.error('âŒ OPENAI_API_KEYê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
  process.exit(1);
}

const express = require('express');
const cors    = require('cors');
const path    = require('path');

const { initializeVectorStore, chunks } = require('./vectorStore');
const askRouter  = require('./routes/ask');
const blogRouter = require('./routes/blog');
const chatRouter = require('./routes/chat');

const app = express();
const PORT = process.env.PORT || 3000;

// 1) ê³µí†µ ë¯¸ë“¤ì›¨ì–´
const allowedOrigins = process.env.ALLOWED_ORIGINS ? 
  process.env.ALLOWED_ORIGINS.split(',') : 
  ['http://localhost:3000', 'http://localhost:3001'];

app.use(cors({
  origin: allowedOrigins,
  methods: ['GET', 'POST', 'DELETE', 'PUT', 'PATCH'],
  credentials: true
}));
app.use(express.json({ limit: '10mb' }));

const { globalErrorHandler } = require('./middleware/errorHandler');

// 2) ì •ì  íŒŒì¼ ì„œë¹™ (chatgpt-client í´ë”)
const clientDir = path.join(__dirname, 'chatgpt-client');
console.log(`ğŸ”§ Serve static files from: ${clientDir}`);
app.use(express.static(clientDir));

// (ì„ íƒ) ë£¨íŠ¸ ê²½ë¡œì—ì„œ index.html ì œê³µ
app.get('/', (req, res) => {
  res.sendFile(path.join(clientDir, 'index.html'));
});

// 4) API ë¼ìš°í„° ì—°ê²°
app.use('/ask', askRouter);
app.use('/blog', blogRouter);
app.use('/chat', chatRouter);
app.use('/classification', require('./routes/classification'));

// RLHF í”¼ë“œë°± ì—”ë“œí¬ì¸íŠ¸
const rlhfManager = require('./lib/rlhfManager');

app.post('/rlhf-feedback', async (req, res) => {
  try {
    const feedbackData = req.body;
    
    console.log('ğŸ“Š RLHF Feedback received:', feedbackData);
    
    // ê°œë³„ í‰ê°€ vs ì¼ê´„ í‰ê°€ êµ¬ë¶„
    let processedFeedback;
    if (feedbackData.type === 'individual_evaluation') {
      // ìƒˆë¡œìš´ ê°œë³„ í‰ê°€ í˜•íƒœ
      processedFeedback = {
        type: 'individual_evaluation',
        filename: feedbackData.filename,
        category: feedbackData.category,
        classificationScore: feedbackData.classificationScore,
        taggingScore: feedbackData.taggingScore,
        improvement: feedbackData.improvement,
        timestamp: feedbackData.timestamp
      };
    } else {
      // ê¸°ì¡´ ì¼ê´„ í‰ê°€ í˜•íƒœ
      processedFeedback = {
        timestamp: feedbackData.timestamp,
        overallScore: feedbackData.overallScore,
        classificationScores: feedbackData.classificationScores,
        taggingScores: feedbackData.taggingScores
      };
    }
    
    // RLHF ë§¤ë‹ˆì €ë¥¼ í†µí•œ í”¼ë“œë°± ì²˜ë¦¬ ë° ì„±ëŠ¥ ê°œì„ 
    const result = await rlhfManager.processNewFeedback(processedFeedback);
    
    res.json(result);
  } catch (error) {
    console.error('âŒ RLHF í”¼ë“œë°± ì²˜ë¦¬ ì˜¤ë¥˜:', error);
    res.status(500).json({ 
      error: 'RLHF í”¼ë“œë°± ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' 
    });
  }
});

// RLHF ì„±ëŠ¥ í†µê³„ ì¡°íšŒ ì—”ë“œí¬ì¸íŠ¸
app.get('/rlhf-stats', (req, res) => {
  try {
    const stats = rlhfManager.getPerformanceStats();
    res.json(stats);
  } catch (error) {
    console.error('âŒ RLHF í†µê³„ ì¡°íšŒ ì˜¤ë¥˜:', error);
    res.status(500).json({ 
      error: 'RLHF í†µê³„ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' 
    });
  }
});

// ë¸”ë¡œê·¸ ì¶”ì¶œ ë° ë¶„ë¥˜ ì—”ë“œí¬ì¸íŠ¸
app.post('/extract-blog', async (req, res) => {
  try {
    const { url } = req.body;
    
    if (!url) {
      return res.status(400).json({
        success: false,
        error: 'URLì´ í•„ìš”í•©ë‹ˆë‹¤.'
      });
    }
    
    console.log('ğŸ”— ë¸”ë¡œê·¸ ì¶”ì¶œ ìš”ì²­:', url);
    
    // ë¸”ë¡œê·¸ ì¶”ì¶œ ë° ë¶„ë¥˜ ì‹¤í–‰
    const result = await extractAndClassifyBlog(url);
    
    res.json({
      success: true,
      message: 'ë¸”ë¡œê·¸ ì¶”ì¶œ ë° ë¶„ë¥˜ ì™„ë£Œ',
      newFiles: result.newFiles || 0,
      categories: result.categories || []
    });
    
  } catch (error) {
    console.error('âŒ ë¸”ë¡œê·¸ ì¶”ì¶œ ì˜¤ë¥˜:', error);
    res.status(500).json({
      success: false,
      error: error.message || 'ë¸”ë¡œê·¸ ì¶”ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
    });
  }
});

// ë¸”ë¡œê·¸ ì¶”ì¶œ ë° ë¶„ë¥˜ í•¨ìˆ˜
async function extractAndClassifyBlog(url) {
  const AutoClassificationManager = require('./lib/autoClassificationManager');
  const fs = require('fs');
  const path = require('path');
  
  console.log('ğŸ“¥ ë¸”ë¡œê·¸ ë‚´ìš© ì¶”ì¶œ ì‹œì‘...');
  
  let blogContent = '';
  
  // ë„¤ì´ë²„ ë¸”ë¡œê·¸ëŠ” JavaScript ë Œë”ë§ì´ í•„ìš”í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ puppeteer ì‹œë„
  if (url.includes('blog.naver.com')) {
    try {
      console.log('ğŸ¤– Puppeteerë¥¼ ì‚¬ìš©í•œ ë™ì  ë Œë”ë§ ì‹œë„...');
      
      // puppeteerê°€ ì„¤ì¹˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
      let puppeteer;
      try {
        puppeteer = require('puppeteer');
      } catch (err) {
        console.log('âš ï¸ Puppeteerê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. ê¸°ë³¸ fetch ì‚¬ìš©...');
        throw new Error('Puppeteer not available');
      }
      
      const browser = await puppeteer.launch({ 
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
      });
      
      const page = await browser.newPage();
      await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');
      
      // í˜ì´ì§€ ë¡œë“œ ë° ëŒ€ê¸°
      await page.goto(url, { waitUntil: 'networkidle2', timeout: 10000 });
      
      // ë¸”ë¡œê·¸ ì½˜í…ì¸ ê°€ ë¡œë“œë  ë•Œê¹Œì§€ ì ì‹œ ëŒ€ê¸°
      await page.waitForTimeout(2000);
      
      // ì‹¤ì œ í…ìŠ¤íŠ¸ ì¶”ì¶œ
      const extractedText = await page.evaluate(() => {
        // ë„¤ì´ë²„ ë¸”ë¡œê·¸ íŠ¹ì • ì…€ë ‰í„°ë¡œ í…ìŠ¤íŠ¸ ì¶”ì¶œ
        const selectors = [
          '.se-main-container',
          '.postViewArea',
          '.post_ct',
          '.se-text',
          'article',
          'main'
        ];
        
        let content = '';
        
        for (const selector of selectors) {
          const elements = document.querySelectorAll(selector);
          if (elements.length > 0) {
            elements.forEach(el => {
              const text = el.innerText || el.textContent;
              if (text && text.trim().length > 50) {
                content += text.trim() + ' ';
              }
            });
            if (content.length > 100) break;
          }
        }
        
        // ì œëª©ë„ ì¶”ì¶œ
        const title = document.querySelector('title')?.textContent || '';
        
        return {
          title: title.trim(),
          content: content.trim()
        };
      });
      
      await browser.close();
      
      if (extractedText.content && extractedText.content.length > 50) {
        let cleanTitle = extractedText.title;
        if (cleanTitle.includes(' : ')) {
          cleanTitle = cleanTitle.split(' : ')[0].trim();
        }
        
        blogContent = (cleanTitle ? cleanTitle + '\n\n' : '') + extractedText.content;
        console.log(`âœ… Puppeteer ì¶”ì¶œ ì„±ê³µ (ì œëª©: ${cleanTitle.length}ì, ë³¸ë¬¸: ${extractedText.content.length}ì)`);
      } else {
        throw new Error('Puppeteerë¡œë„ ì¶©ë¶„í•œ í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•  ìˆ˜ ì—†ìŒ');
      }
      
    } catch (puppeteerError) {
      console.log(`âš ï¸ Puppeteer ì‹¤íŒ¨: ${puppeteerError.message}, fetch ë°©ì‹ìœ¼ë¡œ ëŒ€ì²´`);
      
      // ê¸°ë³¸ fetch ë°©ì‹ìœ¼ë¡œ ëŒ€ì²´
      const response = await fetch(url, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      const html = await response.text();
      
      // ê¸°ì¡´ HTML íŒŒì‹± ë¡œì§ ì‹¤í–‰
      blogContent = await processHtmlContent(html, url);
    }
  } else {
    // ì¼ë°˜ ì›¹ì‚¬ì´íŠ¸ëŠ” ê¸°ë³¸ fetch ì‚¬ìš©
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const html = await response.text();
    blogContent = await processHtmlContent(html, url);
  }
  
  // HTML ì²˜ë¦¬ í•¨ìˆ˜
  async function processHtmlContent(html, url) {
    // ìŠ¤ë§ˆíŠ¸ í…ìŠ¤íŠ¸ ì¶”ì¶œ (ë„ë©”ì¸ë³„ ìµœì í™”)
    let text = '';
    
    if (url.includes('blog.naver.com')) {
      console.log('ğŸ”§ ë„¤ì´ë²„ ë¸”ë¡œê·¸ ê°ì§€ - ê³ ê¸‰ ì¶”ì¶œ ëª¨ë“œ');
      
      // ë„¤ì´ë²„ ë¸”ë¡œê·¸ ë‹¤ì¤‘ ì ‘ê·¼ ë°©ì‹
      const approaches = [];
      
      // 1. URL íŒŒë¼ë¯¸í„° íŒŒì‹±
      const blogIdMatch = url.match(/blogId=([^&]+)/);
      const logNoMatch = url.match(/logNo=(\d+)/);
      
      if (blogIdMatch && logNoMatch) {
        // ì§ì ‘ API í˜•íƒœë¡œ ì ‘ê·¼
        approaches.push(`https://blog.naver.com/PostView.naver?blogId=${blogIdMatch[1]}&logNo=${logNoMatch[1]}&redirect=Dlog&widgetTypeCall=true`);
        approaches.push(`https://blog.naver.com/${blogIdMatch[1]}/${logNoMatch[1]}`);
        // ì›ë³¸ URLë„ ì‹œë„
        approaches.push(url);
      }
      
      // 2. ëª¨ë°”ì¼ ë²„ì „ ì‹œë„
      approaches.push(url.replace('blog.naver.com', 'm.blog.naver.com'));
      
      console.log(`ğŸ”§ ì‹œë„í•  URL ëª©ë¡:`, approaches);
      
      for (const approachUrl of approaches) {
        try {
          console.log(`ğŸ”„ ì‹œë„: ${approachUrl}`);
          const naverResponse = await fetch(approachUrl, {
            headers: {
              'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15',
              'Accept': '*/*',
              'Accept-Language': 'ko-KR,ko;q=0.9'
            }
          });
          
          if (naverResponse.ok) {
            const naverHtml = await naverResponse.text();
            
            // ë„¤ì´ë²„ ë¸”ë¡œê·¸ ì œëª©+ë³¸ë¬¸ ì¶”ì¶œ
            let title = '';
            let content = '';
            
            // 1. ì œëª© ì¶”ì¶œ (ë” ê´‘ë²”ìœ„í•œ íŒ¨í„´)
            const titlePatterns = [
              /<title[^>]*>([^<]+)<\/title>/i,
              /<h1[^>]*>([^<]+)<\/h1>/i,
              /<h2[^>]*>([^<]+)<\/h2>/i,
              /<div[^>]*title[^>]*>([^<]+)<\/div>/i,
              /<span[^>]*title[^>]*>([^<]+)<\/span>/i,
              /"title":"([^"]+)"/i
            ];
            
            for (const pattern of titlePatterns) {
              const match = naverHtml.match(pattern);
              if (match && match[1].trim()) {
                title = match[1].trim();
                console.log(`ğŸ“ ì œëª© ì¶”ì¶œ: "${title}"`);
                break;
              }
            }
            
            // 2. ë³¸ë¬¸ ì½˜í…ì¸ ë§Œ ì¶”ì¶œ (ë” í¬ê´„ì ì¸ íŒ¨í„´)
            const contentPatterns = [
              // ìŠ¤ë§ˆíŠ¸ì—ë””í„° ë³¸ë¬¸ (ê°€ì¥ ì¼ë°˜ì )
              /<div[^>]*se-main-container[^>]*>([\s\S]*?)<\/div>/i,
              /<div[^>]*se-component[^>]*>([\s\S]*?)<\/div>/gi, // ì—¬ëŸ¬ ì»´í¬ë„ŒíŠ¸
              /<div[^>]*post-content[^>]*>([\s\S]*?)<\/div>/i,
              /<div[^>]*post_content[^>]*>([\s\S]*?)<\/div>/i,
              // ì¼ë°˜ ë¸”ë¡œê·¸ ë³¸ë¬¸
              /<div[^>]*postViewArea[^>]*>([\s\S]*?)<\/div>/i,
              /<div[^>]*post_ct[^>]*>([\s\S]*?)<\/div>/i,
              // ëª¨ë°”ì¼ ë²„ì „
              /<div[^>]*_postViewArea[^>]*>([\s\S]*?)<\/div>/i,
              // ì „ì²´ body (ìµœí›„ ìˆ˜ë‹¨)
              /<body[^>]*>([\s\S]*?)<\/body>/i
            ];
            
            for (const pattern of contentPatterns) {
              const match = naverHtml.match(pattern);
              if (match && match[1].trim()) {
                content = match[1];
                console.log(`ğŸ“„ ë³¸ë¬¸ íŒ¨í„´ ë§¤ì¹­ ì„±ê³µ (${content.length}ì)`);
                break;
              }
            }
            
            // 3. ë³¸ë¬¸ ì²˜ë¦¬ ë° í…ìŠ¤íŠ¸ ì¶”ì¶œ
            if (content) {
              console.log(`ğŸ“„ ì›ë³¸ ë³¸ë¬¸ ê¸¸ì´: ${content.length}ì`);
              console.log(`ğŸ“„ ë³¸ë¬¸ ìƒ˜í”Œ: "${content.substring(0, 500)}..."`);
              
              // ë„¤ì´ë²„ ìŠ¤ë§ˆíŠ¸ì—ë””í„° íŠ¹ìˆ˜ ì²˜ë¦¬: ì‹¤ì œ í…ìŠ¤íŠ¸ëŠ” íŠ¹ì • ì†ì„±ì´ë‚˜ JSONì— ìˆì„ ìˆ˜ ìˆìŒ
              let actualText = '';
              
              // 1. data ì†ì„±ì—ì„œ í…ìŠ¤íŠ¸ ì°¾ê¸°
              const dataMatches = content.match(/data-text="([^"]+)"/gi);
              if (dataMatches) {
                dataMatches.forEach(match => {
                  const text = match.replace(/data-text="([^"]+)"/i, '$1');
                  actualText += text + ' ';
                });
                console.log(`ğŸ“„ data ì†ì„±ì—ì„œ ì¶”ì¶œ: "${actualText}"`);
              }
              
              // 2. JSON êµ¬ì¡°ì—ì„œ í…ìŠ¤íŠ¸ ì°¾ê¸°
              const jsonMatches = content.match(/"text":\s*"([^"]+)"/gi);
              if (jsonMatches) {
                jsonMatches.forEach(match => {
                  const text = match.replace(/"text":\s*"([^"]+)"/i, '$1');
                  if (text.length > 10) {
                    actualText += text + ' ';
                  }
                });
                console.log(`ğŸ“„ JSONì—ì„œ ì¶”ì¶œ: "${actualText}"`);
              }
              
              // 3. ëª¨ë“  í…ìŠ¤íŠ¸ ë…¸ë“œë¥¼ ê°•ì œë¡œ ì¶”ì¶œ (ë” ê´€ëŒ€í•œ ë°©ì‹)
              const allTextNodes = content.match(/>([^<]+)</g);
              if (allTextNodes) {
                const meaningfulTexts = [];
                console.log(`ğŸ” ë°œê²¬ëœ ëª¨ë“  í…ìŠ¤íŠ¸ ë…¸ë“œ (${allTextNodes.length}ê°œ):`);
                
                allTextNodes.forEach((match, index) => {
                  let text = match.replace(/[><]/g, '').trim();
                  
                  // ë””ë²„ê¹…: ëª¨ë“  í…ìŠ¤íŠ¸ ì¶œë ¥
                  if (index < 10) { // ì²˜ìŒ 10ê°œë§Œ
                    console.log(`  [${index}] "${text}"`);
                  }
                  
                  // ë” ê´€ëŒ€í•œ ì¡°ê±´ìœ¼ë¡œ ìˆ˜ì •
                  if (text.length >= 3 && 
                      (/[ê°€-í£]/.test(text) || /[a-zA-Z]/.test(text)) && 
                      !text.includes('width') && 
                      !text.includes('%') &&
                      !text.includes('se-') &&
                      !text.includes('style') &&
                      !text.includes('margin') &&
                      !text.includes('padding') &&
                      !text.match(/^\s*$/)) {
                    meaningfulTexts.push(text);
                  }
                });
                
                console.log(`ğŸ“„ ì˜ë¯¸ìˆëŠ” í…ìŠ¤íŠ¸ (${meaningfulTexts.length}ê°œ): "${meaningfulTexts.join(' | ')}"`);
                
                if (meaningfulTexts.length > 0) {
                  actualText += meaningfulTexts.join(' ');
                }
              }
              
              // 4. ë” êµ¬ì²´ì ì¸ ë„¤ì´ë²„ ìŠ¤ë§ˆíŠ¸ì—ë””í„° íŒ¨í„´
              const seContentMatches = content.match(/<div[^>]*se-text[^>]*>[\s\S]*?<\/div>/gi);
              if (seContentMatches) {
                seContentMatches.forEach(match => {
                  const innerText = match.replace(/<[^>]*>/g, ' ').replace(/&[a-z]+;/gi, ' ').trim();
                  if (innerText.length > 5) {
                    actualText += innerText + ' ';
                  }
                });
                console.log(`ğŸ“„ se-text ì»´í¬ë„ŒíŠ¸ì—ì„œ ì¶”ì¶œ: "${actualText}"`);
              }
              
              // ì‹¤ì œ í…ìŠ¤íŠ¸ê°€ ë°œê²¬ë˜ë©´ ì‚¬ìš©
              if (actualText.trim().length > 20) {
                let cleanTitle = title;
                if (cleanTitle.includes(' : ')) {
                  cleanTitle = cleanTitle.split(' : ')[0].trim();
                }
                
                text = (cleanTitle ? cleanTitle + '\n\n' : '') + actualText.trim();
                console.log(`âœ… íŠ¹ìˆ˜ ì¶”ì¶œ ì„±ê³µ (ì œëª©: ${cleanTitle.length}ì, ë³¸ë¬¸: ${actualText.trim().length}ì)`);
              } else {
                // ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ì§„í–‰
                console.log(`âš ï¸ íŠ¹ìˆ˜ ì¶”ì¶œ ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©`);
                
                // ë‹¨ê³„ì  ì •ë¦¬
                let cleanedContent = content;
                
                // 1ë‹¨ê³„: ìŠ¤í¬ë¦½íŠ¸, ìŠ¤íƒ€ì¼ ì œê±°
                cleanedContent = cleanedContent
                  .replace(/<script[\s\S]*?<\/script>/gi, '')
                  .replace(/<style[\s\S]*?<\/style>/gi, '');
                
                console.log(`ğŸ“„ ìŠ¤í¬ë¦½íŠ¸/ìŠ¤íƒ€ì¼ ì œê±° í›„: ${cleanedContent.length}ì`);
              
                // 2ë‹¨ê³„: ë¶ˆí•„ìš”í•œ êµ¬ì¡° ìš”ì†Œ ì œê±°
                cleanedContent = cleanedContent
                  .replace(/<nav[\s\S]*?<\/nav>/gi, '')
                  .replace(/<aside[\s\S]*?<\/aside>/gi, '')
                  .replace(/<footer[\s\S]*?<\/footer>/gi, '')
                  .replace(/<div[^>]*comment[^>]*>[\s\S]*?<\/div>/gi, '')
                  .replace(/<div[^>]*advertisement[^>]*>[\s\S]*?<\/div>/gi, '')
                  .replace(/<div[^>]*sidebar[^>]*>[\s\S]*?<\/div>/gi, '')
                  .replace(/<div[^>]*menu[^>]*>[\s\S]*?<\/div>/gi, '');
                
                console.log(`ğŸ“„ êµ¬ì¡° ìš”ì†Œ ì œê±° í›„: ${cleanedContent.length}ì`);
                
                // 3ë‹¨ê³„: ìŠ¤ë§ˆíŠ¸ì—ë””í„° íŠ¹ìˆ˜ ì²˜ë¦¬ í›„ í…ìŠ¤íŠ¸ ì¶”ì¶œ
                let finalText = '';
                
                // ìŠ¤ë§ˆíŠ¸ì—ë””í„° ì»´í¬ë„ŒíŠ¸ë³„ í…ìŠ¤íŠ¸ ì¶”ì¶œ
                
                // 1. se-text ì»´í¬ë„ŒíŠ¸
                const seTextMatches = cleanedContent.match(/<div[^>]*se-text[^>]*>(.*?)<\/div>/gi);
                if (seTextMatches) {
                  seTextMatches.forEach(match => {
                    const text = match.replace(/<[^>]*>/g, ' ').replace(/&[a-z]+;/gi, ' ').trim();
                    if (text.length > 5) {
                      finalText += text + ' ';
                    }
                  });
                  console.log(`ğŸ“„ se-text ì¶”ì¶œ: ${finalText.length}ì`);
                }
                
                // 2. í…Œì´ë¸” ì…€ì—ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ
                const tableCells = cleanedContent.match(/<td[^>]*>(.*?)<\/td>/gi);
                if (tableCells) {
                  tableCells.forEach(cell => {
                    const text = cell.replace(/<[^>]*>/g, ' ').replace(/&[a-z]+;/gi, ' ').trim();
                    if (text.length > 10 && !text.includes('width') && !text.includes('height')) {
                      finalText += text + ' ';
                    }
                  });
                  console.log(`ğŸ“„ í…Œì´ë¸” ì…€ ì¶”ì¶œ: ${finalText.length}ì`);
                }
                
                // 3. ì§ì ‘ í…ìŠ¤íŠ¸ ë…¸ë“œ ì¶”ì¶œ (ì •ê·œì‹ìœ¼ë¡œ)
                const directTextMatches = cleanedContent.match(/>([^<>{]+)</gi);
                if (directTextMatches) {
                  directTextMatches.forEach(match => {
                    const text = match.replace(/[><]/g, '').trim();
                    if (text.length > 15 && 
                        !text.includes('width') && 
                        !text.includes('height') && 
                        !text.includes('margin') &&
                        !text.includes('padding') &&
                        !text.includes('se-') &&
                        !text.match(/^\d+%$/) &&
                        !text.match(/^[\s\n]*$/)) {
                      finalText += text + ' ';
                    }
                  });
                  console.log(`ğŸ“„ ì§ì ‘ í…ìŠ¤íŠ¸ ë…¸ë“œ ì¶”ì¶œ: ${finalText.length}ì`);
                }
                
                // ì¼ë°˜ p íƒœê·¸ì—ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ
                const pMatches = cleanedContent.match(/<p[^>]*>(.*?)<\/p>/gi);
                if (pMatches) {
                  pMatches.forEach(match => {
                    const text = match.replace(/<[^>]*>/g, ' ').replace(/&[a-z]+;/gi, ' ').trim();
                    if (text.length > 10) {
                      finalText += text + ' ';
                    }
                  });
                  console.log(`ğŸ“„ p íƒœê·¸ í…ìŠ¤íŠ¸ ì¶”ê°€: ${finalText.length}ì`);
                }
                
                // span íƒœê·¸ì—ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ (ê¸¸ì´ ì œí•œ)
                const spanMatches = cleanedContent.match(/<span[^>]*>([^<]+)<\/span>/gi);
                if (spanMatches) {
                  spanMatches.forEach(match => {
                    const text = match.replace(/<[^>]*>/g, ' ').replace(/&[a-z]+;/gi, ' ').trim();
                    if (text.length > 15 && !text.includes('í´ë¦­') && !text.includes('ë¬¸ì˜')) {
                      finalText += text + ' ';
                    }
                  });
                  console.log(`ğŸ“„ span íƒœê·¸ í…ìŠ¤íŠ¸ ì¶”ê°€: ${finalText.length}ì`);
                }
                
                // ë§ˆì§€ë§‰ ìˆ˜ë‹¨: ëª¨ë“  HTML ì œê±°
                if (finalText.length < 100) {
                  finalText = cleanedContent
                    .replace(/<[^>]*>/g, ' ')
                    .replace(/&nbsp;/g, ' ')
                    .replace(/&[a-z]+;/gi, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
                  console.log(`ğŸ“„ ì „ì²´ HTML ì œê±° ë°©ì‹: ${finalText.length}ì`);
                }
                
                // ìµœì¢… ì •ë¦¬
                finalText = finalText
                  .replace(/\s+/g, ' ')
                  .trim();
                
                console.log(`ğŸ“„ ìµœì¢… í…ìŠ¤íŠ¸: ${finalText.length}ì`);
                
                if (finalText.length > 50) {
                  // ì œëª© ì •ë¦¬ (ë„¤ì´ë²„ ë¸”ë¡œê·¸ ì œëª©ì—ì„œ ì‚¬ì´íŠ¸ëª… ì œê±°)
                  let cleanTitle = title;
                  if (cleanTitle.includes(' : ')) {
                    cleanTitle = cleanTitle.split(' : ')[0].trim();
                  }
                  if (cleanTitle.includes(' - ')) {
                    cleanTitle = cleanTitle.split(' - ')[0].trim();
                  }
                  
                  text = (cleanTitle ? cleanTitle + '\n\n' : '') + finalText;
                  console.log(`âœ… ë„¤ì´ë²„ ì œëª©+ë³¸ë¬¸ ì¶”ì¶œ ì„±ê³µ (ì œëª©: ${cleanTitle.length}ì, ë³¸ë¬¸: ${finalText.length}ì)`);
                } else {
                  console.log(`âš ï¸ ì¶”ì¶œëœ í…ìŠ¤íŠ¸ê°€ ë„ˆë¬´ ì§§ìŒ: "${finalText}"`);
                }
              }
            
            if (!text) {
              // ê¸°ì¡´ íŒ¨í„´ ë§¤ì¹­ ì‹œë„
              const patterns = [
                // ìŠ¤ë§ˆíŠ¸ì—ë””í„° íŒ¨í„´
                /<div[^>]*se-main-container[^>]*>([\s\S]*?)<\/div>/i,
                /<div[^>]*se-component[^>]*>([\s\S]*?)<\/div>/i,
                // ì¼ë°˜ ë¸”ë¡œê·¸ íŒ¨í„´  
                /<div[^>]*postViewArea[^>]*>([\s\S]*?)<\/div>/i,
                /<div[^>]*post_ct[^>]*>([\s\S]*?)<\/div>/i,
                /<div[^>]*blog_content[^>]*>([\s\S]*?)<\/div>/i,
                // ëª¨ë°”ì¼ íŒ¨í„´
                /<div[^>]*post-content[^>]*>([\s\S]*?)<\/div>/i,
                /<div[^>]*_postViewArea[^>]*>([\s\S]*?)<\/div>/i
              ];
            
              for (const pattern of patterns) {
                const match = naverHtml.match(pattern);
                if (match && match[1].trim().length > 100) {
                  text = match[1];
                  console.log(`âœ… ë„¤ì´ë²„ íŒ¨í„´ ì¶”ì¶œ ì„±ê³µ (${text.length}ì)`);
                  console.log(`ğŸ” ì¶”ì¶œëœ ì›ë³¸ í…ìŠ¤íŠ¸ ìƒ˜í”Œ: "${text.substring(0, 200)}..."`);
                  break;
                }
              }
            }
            
            if (text) break; // ì„±ê³µí•˜ë©´ ì¤‘ë‹¨
          }
        } catch (error) {
          console.log(`âš ï¸ ${approachUrl} ì‹¤íŒ¨:`, error.message);
        }
      }
    }
    
    // ì¼ë°˜ ì›¹ì‚¬ì´íŠ¸ ë˜ëŠ” ë„¤ì´ë²„ ì‹¤íŒ¨ ì‹œ
    if (!text) {
      console.log('ğŸ”„ ì¼ë°˜ ì›¹ì‚¬ì´íŠ¸ ì œëª©+ë³¸ë¬¸ ì¶”ì¶œ ëª¨ë“œ');
      
      // ì œëª© ì¶”ì¶œ
      const titleMatch = html.match(/<title[^>]*>([^<]*)<\/title>/i);
      let title = titleMatch ? titleMatch[1].trim() : '';
      
      // ì‚¬ì´íŠ¸ëª… ì œê±° (ì˜ˆ: "ì œëª© - ì‚¬ì´íŠ¸ëª…" â†’ "ì œëª©")
      if (title.includes(' - ')) {
        title = title.split(' - ')[0].trim();
      }
      if (title.includes(' | ')) {
        title = title.split(' | ')[0].trim();
      }
      
      // ë³¸ë¬¸ ì½˜í…ì¸  ì¶”ì¶œ (article, main ìš°ì„ )
      let content = '';
      const contentPatterns = [
        /<article[^>]*>([\s\S]*?)<\/article>/i,
        /<main[^>]*>([\s\S]*?)<\/main>/i,
        /<div[^>]*content[^>]*>([\s\S]*?)<\/div>/i,
        /<div[^>]*post[^>]*>([\s\S]*?)<\/div>/i,
        /<div[^>]*entry[^>]*>([\s\S]*?)<\/div>/i
      ];
      
      for (const pattern of contentPatterns) {
        const match = html.match(pattern);
        if (match && match[1].trim()) {
          content = match[1];
          console.log(`ğŸ“„ ì¼ë°˜ ì›¹ì‚¬ì´íŠ¸ ë³¸ë¬¸ íŒ¨í„´ ë§¤ì¹­ ì„±ê³µ (${content.length}ì)`);
          break;
        }
      }
      
      if (content) {
        // ë¶ˆí•„ìš”í•œ ìš”ì†Œ ì œê±°
        content = content
          .replace(/<script[\s\S]*?<\/script>/gi, '')
          .replace(/<style[\s\S]*?<\/style>/gi, '')
          .replace(/<nav[\s\S]*?<\/nav>/gi, '')
          .replace(/<header[\s\S]*?<\/header>/gi, '')
          .replace(/<footer[\s\S]*?<\/footer>/gi, '')
          .replace(/<aside[\s\S]*?<\/aside>/gi, '')
          .replace(/<div[^>]*sidebar[^>]*>[\s\S]*?<\/div>/gi, '')
          .replace(/<div[^>]*menu[^>]*>[\s\S]*?<\/div>/gi, '')
          .replace(/<div[^>]*comment[^>]*>[\s\S]*?<\/div>/gi, '');
        
        console.log(`ğŸ“„ ë¶ˆí•„ìš”í•œ ìš”ì†Œ ì œê±° í›„: ${content.length}ì`);
        
        // HTML íƒœê·¸ ì œê±°í•˜ì—¬ ìˆœìˆ˜ í…ìŠ¤íŠ¸ë§Œ
        const cleanContent = content
          .replace(/<[^>]*>/g, ' ')
          .replace(/&nbsp;/g, ' ')
          .replace(/&[a-z]+;/gi, ' ')
          .replace(/\s+/g, ' ')
          .trim();
        
        if (cleanContent.length > 100) {
          text = (title ? title + '\n\n' : '') + cleanContent;
          console.log(`âœ… ì¼ë°˜ ì›¹ì‚¬ì´íŠ¸ ì œëª©+ë³¸ë¬¸ ì¶”ì¶œ ì„±ê³µ (ì œëª©: ${title.length}ì, ë³¸ë¬¸: ${cleanContent.length}ì)`);
        }
      }
    }
    
    // ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ê²€ì¦
    if (!text || text.trim().length === 0) {
      throw new Error('í…ìŠ¤íŠ¸ ì¶”ì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    }
    
    console.log(`ğŸ”§ ìµœì¢… ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ê¸¸ì´: ${text.length}ì`);
    
    // ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ìƒ˜í”Œ ì¶œë ¥ (ë””ë²„ê¹…ìš©)
    if (text.length < 200) {
      console.log(`ğŸ” ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ì „ì²´: "${text}"`);
    } else {
      console.log(`ğŸ” ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ìƒ˜í”Œ: "${text.substring(0, 200)}..."`);
    }
    
    // í† í° ì ˆì•½ì„ ìœ„í•´ ê¸¸ì´ ì œí•œ (ë¶„ë¥˜ì— ì¶©ë¶„í•œ ì •ë„)
    if (text.length > 2000) {
      // ì•ë¶€ë¶„ 1000ì + ë’·ë¶€ë¶„ 1000ìë¡œ í•µì‹¬ ë‚´ìš© ìœ ì§€
      text = text.substring(0, 1000) + '...[ì¤‘ëµ]...' + text.substring(text.length - 1000);
    }
    
    blogContent = text;
    console.log(`âœ… ë¸”ë¡œê·¸ ë‚´ìš© ì¶”ì¶œ ì™„ë£Œ (ìµœì¢… ${text.length}ì)`);
    
    return text;
    
  } catch (error) {
    console.error('âŒ ë¸”ë¡œê·¸ í¬ë¡¤ë§ ì‹¤íŒ¨:', error.message);
    throw new Error(`ë¸”ë¡œê·¸ í¬ë¡¤ë§ ì‹¤íŒ¨: ${error.message}. í•´ë‹¹ URLì—ì„œ ë‚´ìš©ì„ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
  }
  
  // ì¶”ì¶œëœ ë‚´ìš©ì´ ë„ˆë¬´ ì§§ìœ¼ë©´ ì‹¤íŒ¨ë¡œ ì²˜ë¦¬
  if (!blogContent || blogContent.trim().length < 50) {
    throw new Error('ì¶”ì¶œëœ ë¸”ë¡œê·¸ ë‚´ìš©ì´ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤. ë‹¤ë¥¸ URLì„ ì‹œë„í•´ì£¼ì„¸ìš”.');
  }
  
  console.log('ğŸ¤– Claude ìë™ ë¶„ë¥˜ ì‹œì‘...');
  
  const classifier = new AutoClassificationManager();
  const categories = ['title', 'firstparagraph', 'closing'];
  let newFiles = 0;
  const processedCategories = [];
  
  for (const category of categories) {
    try {
      const result = await classifier.classifyContent(category, blogContent);
      if (result) {
        // íŒŒì¼ ì €ì¥
        const categoryDir = path.join(__dirname, 'auto_classified', category);
        if (!fs.existsSync(categoryDir)) {
          fs.mkdirSync(categoryDir, { recursive: true });
        }
        
        const existingFiles = fs.readdirSync(categoryDir).filter(f => f.endsWith('.txt'));
        const nextIndex = existingFiles.length + 1;
        const filename = category.substring(0, 2) + '_' + String(nextIndex).padStart(3, '0') + '.txt';
        
        const fileContent = `===user===
${result}
===assistant===
${blogContent}`;
        
        const filePath = path.join(categoryDir, filename);
        fs.writeFileSync(filePath, fileContent, 'utf8');
        
        newFiles++;
        processedCategories.push(category);
        console.log(`âœ… ${category} ì €ì¥ë¨: ${filename}`);
      }
    } catch (error) {
      console.error(`âŒ ${category} ë¶„ë¥˜ ì˜¤ë¥˜:`, error.message);
    }
  }
  
  return {
    newFiles,
    categories: processedCategories
  };
}

// ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬ ì—”ë“œí¬ì¸íŠ¸ (ë””ë²„ê¹…ìš©)
app.get('/debug/system-status', (req, res) => {
  try {
    const fs = require('fs');
    const path = require('path');
    
    const status = {
      server: {
        status: 'running',
        timestamp: new Date().toISOString(),
        node_version: process.version,
        uptime: process.uptime()
      },
      directories: {
        auto_classified: fs.existsSync('./auto_classified'),
        claude_approved: fs.existsSync('./claude_approved'),
        training_data: fs.existsSync('./training_data'),
        deleted_files: fs.existsSync('./deleted_files'),
        negative_training: fs.existsSync('./negative_training')
      },
      files: {
        rlhf_feedback: fs.existsSync('./rlhf_feedback.jsonl'),
        latest_model: fs.existsSync('./latest_model.txt')
      },
      routes: {
        ask: true,
        blog: true,
        chat: true,
        classification: true
      }
    };
    
    // ê° ì¹´í…Œê³ ë¦¬ë³„ íŒŒì¼ ìˆ˜ í™•ì¸
    const categories = ['title', 'firstparagraph', 'closing', 'story', 'usp'];
    status.file_counts = {};
    
    categories.forEach(category => {
      const categoryPath = `./auto_classified/${category}`;
      if (fs.existsSync(categoryPath)) {
        const files = fs.readdirSync(categoryPath).filter(f => f.endsWith('.txt'));
        status.file_counts[category] = files.length;
      } else {
        status.file_counts[category] = 0;
      }
    });
    
    console.log('ğŸ” ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬ ìš”ì²­:', req.ip);
    res.json(status);
    
  } catch (error) {
    console.error('âŒ ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬ ì˜¤ë¥˜:', error);
    res.status(500).json({
      error: 'ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
      details: error.message
    });
  }
});

// 5) ê¸€ë¡œë²Œ ì—ëŸ¬ í•¸ë“¤ëŸ¬
app.use(globalErrorHandler);

// 5) ë²¡í„° ìŠ¤í† ì–´ ì´ˆê¸°í™” í›„ ì„œë²„ ê¸°ë™
(async () => {
  console.log('â¡ï¸ [vectorStore] initializing...');
  try {
    await initializeVectorStore(process.env.OPENAI_API_KEY);
    console.log(`âœ… [vectorStore] ready with ${chunks.length} chunks`);
    
    const server = app.listen(PORT, () => {
      console.log(`Server running on http://localhost:${PORT}`);
    });
    
    // Graceful shutdown
    process.on('SIGTERM', () => {
      console.log('ğŸ”„ SIGTERM received, shutting down gracefully');
      server.close(() => {
        console.log('âœ… Server closed');
        process.exit(0);
      });
    });
    
    process.on('SIGINT', () => {
      console.log('ğŸ”„ SIGINT received, shutting down gracefully');
      server.close(() => {
        console.log('âœ… Server closed');
        process.exit(0);
      });
    });
    
  } catch (e) {
    console.error('ğŸ”¥ [vectorStore] initialization failed:', e);
    console.error('ğŸ”„ Shutting down server due to initialization failure');
    process.exit(1);
  }
})();
